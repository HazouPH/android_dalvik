/*
 * Copyright (C) 2010-2013 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "CompilationErrorLCG.h"
#include "CompilationUnit.h"
#include "Lower.h"
#include "NcgAot.h"
#include "NcgHelper.h"
#include "Scheduler.h"
#include "Singleton.h"

//returns # of ops generated by this function
//entries relocatable: eip + relativePC
int get_eip_API() {
    call("ncgGetEIP");//%edx //will push eip to stack
    return 1;
}
#define NEW_EXPORT_PC

/**
 * @brief Updates stack save area to contain the given dalvik PC
 * @param dalvikPC The dalvik program counter for instruction we want to execute next
 * @param framePtrRegister The register that holds the frame pointer
 * @param isFramePtrRegPhysical Whether the register holding frame pointer is physical register
 */
static void export_pc (int dalvikPC, int framePtrRegister, bool isFramePtrRegPhysical)
{
    //The stack save area is in negative direction relative to frame pointer so we calculate displacement now
    int displacement = -(sizeof(StackSaveArea)) + OFFSETOF_MEMBER(StackSaveArea, xtra.currentPc);

    //Update the stack save area to contain the proper PC
    move_imm_to_mem (OpndSize_32, dalvikPC, displacement, framePtrRegister, isFramePtrRegPhysical);
}

/**
 * @brief Updates stack save area to contain the current dalvik PC
 */
void export_pc (void)
{
    // check rPC !=0 as it can lead to failure during exception thrown
    if (rPC == 0) {
        ALOGD ("JIT_INFO: The JIT is exporting a PC of 0. This is likely \
                        incorrect thus we reject trace to prevent semantic problem");
        assert(false);
        SET_JIT_ERROR (kJitErrorZeroPC);
        return;
    }
    //Determine PC and register that contains frame pointer
    int dalvikPC = reinterpret_cast<int> (rPC);
    int framePtrRegister = PhysicalReg_FP;
    bool isFramePtrRegPhysical = true;

    //Now call helper that does the work to store the PC to the save area
    export_pc (dalvikPC, framePtrRegister, isFramePtrRegPhysical);
}

/* jump from JIT'ed code to interpreter without chaining */
int jumpToInterpNoChain() {
    typedef void (*vmHelper)(int);
    vmHelper funcPtr = dvmJitToInterpNoChain;
    move_imm_to_reg(OpndSize_32, (int)funcPtr, C_SCRATCH_1, isScratchPhysical);

    unconditional_jump_reg(C_SCRATCH_1, isScratchPhysical);
    if(gDvm.executionMode == kExecutionModeNcgO1) touchEax();
    return 0;
}

/* jump from JIT'ed code to interpreter becaues of exception */
int jumpToInterpPunt() {
    typedef void (*vmHelper)(int);
    vmHelper funcPtr = dvmJitToInterpPunt;
    move_imm_to_reg(OpndSize_32, (int)funcPtr, C_SCRATCH_1, isScratchPhysical);

    unconditional_jump_reg(C_SCRATCH_1, isScratchPhysical);
    //if(gDvm.executionMode == kExecutionModeNcgO1) touchEax();
    return 0;
}

/* jump to common_exceptionThrown from JIT'ed code */
int jumpToExceptionThrown(int exceptionNum) {
    if(gDvm.executionMode == kExecutionModeNcgO1) {
        rememberState(exceptionNum);
        export_pc();
        beforeCall("exception"); //dump GG, GL VRs
    }

    typedef void (*vmHelper)(int);
    vmHelper funcPtr = dvmJitToExceptionThrown;
    move_imm_to_reg(OpndSize_32, (int)funcPtr, C_SCRATCH_1, isScratchPhysical);
    unconditional_jump_reg(C_SCRATCH_1, isScratchPhysical);

    if(gDvm.executionMode == kExecutionModeNcgO1) {
        goToState(exceptionNum);
    }
    return 0;
}

//! generate native code to call dvmNcgInvokeInterpreter

//!the interpreter will start execution from %eax
int invokeInterpreter(bool fromApp)
{
    typedef void (*vmHelper)(int);
    vmHelper funcPtr = dvmNcgInvokeInterpreter;

    move_imm_to_reg(OpndSize_32, (int)funcPtr, C_SCRATCH_1, isScratchPhysical);

    unconditional_jump_reg(C_SCRATCH_1, isScratchPhysical);
    if(gDvm.executionMode == kExecutionModeNcgO1) touchEax();
    return 0;
}

//!work to do before calling a function pointer with code cache enabled

//!
void callFuncPtr(int funcPtr, const char* funcName) {

    move_imm_to_reg(OpndSize_32, (int)funcPtr, C_SCRATCH_1, isScratchPhysical);
    call_reg(C_SCRATCH_1, isScratchPhysical);
}

/* generate a "call imm32" */
void callFuncPtrImm(int funcPtr) {
    Mnemonic m = Mnemonic_CALL;
    if(gDvmJit.scheduling)
        singletonPtr<Scheduler>()->signalEndOfNativeBasicBlock();
    int relOffset = funcPtr - (int)stream - 5; // 5: Bytes of "call imm32"
    dump_imm(m, OpndSize_32, relOffset);
}

//.const_string_resolve: input in %eax, output in %eax
//.const_string_helper:
//.class_resolve: input in %eax, output in %eax
int call_helper_API(const char* helperName) {
    call(helperName);
    return 1;
}

/* check whether we are throwing an exception */
bool jumpToException(const char* target) {
    bool isException = false;
    if(!strncmp(target, "common_err", 10)) isException = true;
    if(!strncmp(target, "common_throw", 12)) isException = true;
    if(!strncmp(target, "common_exception", 16)) isException = true;
    return isException;
}

/* @brief Provides address to global constants
 * @details Essentially provides an associative
 * array of global data values indexed by name
 * @param dataName the string for the data
 * @return pointer to the global data
 */
int getGlobalDataAddr(const char* dataName) {
    int dataAddr = 0;
    if(!strcmp(dataName, "doubNeg")) dataAddr = LdoubNeg;
    else if(!strcmp(dataName, "intMax")) dataAddr = LintMax;
    else if(!strcmp(dataName, "intMin")) dataAddr = LintMin;
    else if(!strcmp(dataName, "valueNanLong")) dataAddr = LvalueNanLong;
    else if(!strcmp(dataName, "valuePosInfLong")) dataAddr = LvaluePosInfLong;
    else if(!strcmp(dataName, "valueNegInfLong")) dataAddr = LvalueNegInfLong;
    else if(!strcmp(dataName, "shiftMask")) dataAddr = LshiftMask;
    else if(!strcmp(dataName, "value64")) dataAddr = Lvalue64;
    else if(!strcmp(dataName, "64bits")) dataAddr = L64bits;
    else if(!strcmp(dataName, "strClassCastExceptionPtr")) dataAddr = LstrClassCastExceptionPtr;
    else if(!strcmp(dataName, "strInstantiationError")) dataAddr = LstrInstantiationErrorPtr;
    else if(!strcmp(dataName, "gDvmInlineOpsTable")) dataAddr = (int)gDvmInlineOpsTable;
    else {
        ALOGI("JIT_INFO: global data %s not supported\n", dataName);
        SET_JIT_ERROR(kJitErrorGlobalData);
    }
    return dataAddr;
}

//for shared code cache, we use scratchRegs[0] & [1]
int load_imm_global_data_API(const char* dataName,
                         OpndSize size,
                         int reg, bool isPhysical) {

    //find the address from name
    int dataAddr = getGlobalDataAddr(dataName);
    if (dataAddr == 0)
        return -1;
    move_imm_to_reg(size, dataAddr, reg, isPhysical);
    return 0;
}
//for shared code cache, we use scratchRegs[0] & [1] & [2]
//FIXME: [2] is assumed to be hard-coded register
int load_global_data_API(const char* dataName,
                         OpndSize size,
                         int reg, bool isPhysical) {

    //find the address from name
    int dataAddr = getGlobalDataAddr(dataName);
    if (dataAddr == 0)
        return -1;
    move_mem_to_reg(size, dataAddr, PhysicalReg_Null, true, reg, isPhysical);
    return 0;
}
int load_sd_global_data_API(const char* dataName,
                            int reg, bool isPhysical) {

    //find the address from name
    int dataAddr = getGlobalDataAddr(dataName);
    if (dataAddr == 0)
        return -1;
    move_sd_mem_to_reg(dataAddr, PhysicalReg_Null, true, reg, isPhysical);
    return 0;
}

int load_fp_stack_global_data_API(const char* dataName,
                                  OpndSize size) {

    int dataAddr = getGlobalDataAddr(dataName);
    if (dataAddr == 0)
        return -1;
    load_int_fp_stack_imm(size, dataAddr); //fildl
    return 0;
}
